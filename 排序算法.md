##### 排序算法笔记
1. 冒泡排序
   ````java
   /* 冒泡排序优化：使用变量记录当前轮次是否发生交换外，再使用一个变
   量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较 */
   public static void bubbleSort(int[] arr) {
       boolean swapped = true;
       // 最后一个没有经过排序的元素的下标
       int indexOfLastUnsortedElement = arr.length - 1;
       // 上次发生交换的位置
       int swappedIndex = -1;
       while (swapped) {
        swapped = false;
        for (int i = 0; i < indexOfLastUnsortedElement; i++) {
         if (arr[i] > arr[i + 1]) {
          // 如果左边的数大于右边的数，则交换，保证右边的数字最大
          int temp = arr[i];
          arr[i] = arr[i + 1];
          arr[i + 1] = temp;
          // 表示发生了交换
          swapped = true;
          // 更新交换的位置
          swappedIndex = i;
         }
        }
        // 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置
        indexOfLastUnsortedElement = swappedIndex;
       }
    }
   ````
2. 选择排序
   - 每一轮寻找数组中最小值，将其放到数组最前面
   - 现在让我们思考一下，冒泡排序和选择排序有什么异同？
     相同点：
     1. 都是两层循环，时间复杂度都为 O(n^2)
     2. 都只使用有限个变量，空间复杂度 O(1)O(1)。
   
     不同点：
     1. 冒泡排序在比较过程中就不断交换；而选择排序增加了一个变量保存最小值 / 最大值的下标，遍历完成后才交换，减少了交换次数。
     2. 冒泡排序法是稳定的，选择排序法是不稳定的。
   ```javascript
   var sortArray = function(nums) {
    for (let i = 0; i < nums.length - 1; i++) {
        let minIndex = i;
        for (let j = i; j < nums.length; j++) {
            if (nums[minIndex] > nums[j]) {
                minIndex = j;
            }
        }
        let temp = nums[minIndex];
        nums[minIndex] = nums[i];
        nums[i] = temp;
    }
    return nums;
   };
   ```
3. 插入排序
    - 这种方式就像是这个新加入的数字原本坐在一排数字的最后一位，然后它不断地与前面的数字比较，如果前面的数字比它大，它就和前面的数字交换位置。
    分析可知，插入排序的过程不会破坏原有数组中相同关键字的相对次序，所以插入排序是一种稳定的排序算法。
    ```javascript
    var sortArray = function(nums) {
      for (let i = 1; i < nums.length; i++) {
          let j = i;
          while (j >= 1 && nums[j] < nums[j - 1]) {
              let temp = nums[j - 1];
              nums[j - 1] = nums[j];
              nums[j] = temp;
              j--;
          }
      }
      return nums;
    };
    ```
4. 归并排序
   - 我把数组不断地拆成两份，直到只剩下一个数字时，这一个数字组成 
   的数组我们就可以认为它是有序的。然后通过双指针方式，遍历两个有序数组，每次选取两个数组中较小的那个，指针后移。将 1 个数字组成的有序数组合并成一个包含 2 个数字的有序数组，再将 2 个数字组成的有序数组合并成包含 4 个数字的有序数组...直到整个数组排序完成，这就是归并排序（Merge Sort）的思想。
   ```javascript
   function merge(nums, start, end, result) {
       let mid = parseInt((start + end) / 2);
       let index1 = start;
       let index2 = mid + 1;
       let rindex = start;

       while(index1 <= mid && index2 <= end) {
           if (nums[index1] <= nums[index2]) {
               result[rindex++] = nums[index1++];
           } else {
               result[rindex++] = nums[index2++];
           }
       }

       while (index1 <= mid) {
           result[rindex++] = nums[index1++];
       }
       while (index2 <= end) {
           result[rindex++] = nums[index2++];
       }
       while (start <= end) {
           nums[start] = result[start++];
       }
    }

   function mergesort(nums, start, end, result) {
       if (start >= end){
           return;
       }
       let mid = parseInt((start + end) / 2);
       mergesort(nums, start, mid, result);
       mergesort(nums, mid + 1, end, result);

       merge(nums, start, end, result);
   }

   var sortArray = function(nums) {
       if (nums.length <= 1) {
           return nums;
       }
       let result = new Array(nums.length);
       mergesort(nums, 0, nums.length - 1, result);
       return result
   };
   ```

