##### 排序算法笔记
1. 冒泡排序
   ````java
   /* 冒泡排序优化：使用变量记录当前轮次是否发生交换外，再使用一个变
   量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较 */
   public static void bubbleSort(int[] arr) {
       boolean swapped = true;
       // 最后一个没有经过排序的元素的下标
       int indexOfLastUnsortedElement = arr.length - 1;
       // 上次发生交换的位置
       int swappedIndex = -1;
       while (swapped) {
        swapped = false;
        for (int i = 0; i < indexOfLastUnsortedElement; i++) {
         if (arr[i] > arr[i + 1]) {
          // 如果左边的数大于右边的数，则交换，保证右边的数字最大
          int temp = arr[i];
          arr[i] = arr[i + 1];
          arr[i + 1] = temp;
          // 表示发生了交换
          swapped = true;
          // 更新交换的位置
          swappedIndex = i;
         }
        }
        // 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置
        indexOfLastUnsortedElement = swappedIndex;
       }
    }
   ````
2. 选择排序
   - 每一轮寻找数组中最小值，将其放到数组最前面
   - 现在让我们思考一下，冒泡排序和选择排序有什么异同？
     相同点：
     1. 都是两层循环，时间复杂度都为 O(n^2)
     2. 都只使用有限个变量，空间复杂度 O(1)O(1)。
   
     不同点：
     1. 冒泡排序在比较过程中就不断交换；而选择排序增加了一个变量保存最小值 / 最大值的下标，遍历完成后才交换，减少了交换次数。
     2. 冒泡排序法是稳定的，选择排序法是不稳定的。
   ```javascript
   var sortArray = function(nums) {
    for (let i = 0; i < nums.length - 1; i++) {
        let minIndex = i;
        for (let j = i; j < nums.length; j++) {
            if (nums[minIndex] > nums[j]) {
                minIndex = j;
            }
        }
        let temp = nums[minIndex];
        nums[minIndex] = nums[i];
        nums[i] = temp;
    }
    return nums;
   };
   ```
3. 插入排序
    - 这种方式就像是这个新加入的数字原本坐在一排数字的最后一位，然后它不断地与前面的数字比较，如果前面的数字比它大，它就和前面的数字交换位置。
    分析可知，插入排序的过程不会破坏原有数组中相同关键字的相对次序，所以插入排序是一种稳定的排序算法。
    ```javascript
    var sortArray = function(nums) {
      for (let i = 1; i < nums.length; i++) {
          let j = i;
          while (j >= 1 && nums[j] < nums[j - 1]) {
              let temp = nums[j - 1];
              nums[j - 1] = nums[j];
              nums[j] = temp;
              j--;
          }
      }
      return nums;
    };
    ```
